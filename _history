{"entries":[{"timestamp":1749607676160,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"20\" y=\"20\""],[0,"></b"]],"start1":67,"start2":67,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":23,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"ExpansionBoard.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":252,"start2":252,"length1":74,"length2":44}]},{"type":"added","filename":"ExpansionBoard.ts","value":"\n/**\n* 使用此文件来定义自定义函数和图形块。\n* 想了解更详细的信息，请前往 https://makecode.microbit.org/blocks/custom\n*/\n\n//Motor selection enumeration\nexport enum MyEnumMotor {\n    //% block=\"M1\"\n    M1,\n    //% block=\"M2\"\n    M2,\n    //% block=\"M3\"\n    M3,\n    //% block=\"M4\"\n    M4,\n    //% block=\"ALL\"\n    ALL,\n};\n\n//Motor direction enumeration selection\nexport enum MyEnumDir {\n    //% block=\"forward\"\n    Forward,\n    //% block=\"backward\"\n    Backward,\n};\n\nexport enum Servos {\n    //% blockId=\"S1\" block=\"S1\"\n    S1,\n    //% blockId=\"S2\" block=\"S2\"\n    S2,\n    //% blockId=\"S3\" block=\"S3\"\n    S3,\n    //% blockId=\"S4\" block=\"S4\"\n    S4\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n\n}\n"}]},{"timestamp":1749608260133,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"><block "],[1,"type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block "],[0,"type=\"de"]],"start1":77,"start2":77,"length1":16,"length2":65},{"diffs":[[0,"ver\" x=\""],[-1,"0"],[1,"225"],[0,"\" y=\""],[1,"2"],[0,"0\"></blo"]],"start1":151,"start2":151,"length1":22,"length2":25}]},{"type":"edited","filename":"ExpansionBoard.ts","patch":[{"diffs":[[0,"enumeration\n"],[1,"export "],[0,"enum MyEnumM"]],"start1":108,"start2":108,"length1":24,"length2":31},{"diffs":[[0,"lection\n"],[1,"export "],[0,"enum MyE"]],"start1":319,"start2":319,"length1":16,"length2":23},{"diffs":[[0,"rd,\n};\n\n"],[1,"export "],[0,"enum Ser"]],"start1":423,"start2":423,"length1":16,"length2":23},{"diffs":[[0,"\n}\n\n"],[-1,"enum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\nenum PinNumber {\n    //% block=\"C0\"\n    C0 = 0,\n    //% block=\"C1\"\n    C1 = 1,\n    //% block=\"C2\"\n    C2 = 2\n}\n\nenum PinMode {\n    //% block=\"ADC\"\n    ADC = 0,\n    //% block=\"DHT11\"\n    DHT11 = 1,\n    //% block=\"DHT22\"\n    DHT22 = 2,\n    //% block=\"DS18B20\"\n    DS18B20 = 3,\n    //% block=\"Digital OUT\"\n    WriteGpio = 4,\n    //% block=\"Digital IN\"\n    ReadGpio = 5\n}\n\nenum PinState {\n    //% block=\"low\"\n    Low = 0,\n    //% block=\"high\"\n    High = 1\n}\n\n// 传感器类型枚举\nenum SensorType {\n    //% block=\"ADC\"\n    Analog = 0,\n    //% block=\"digital in\"\n    Digital = 1,\n    //% block=\"DHT11Temperature\"\n    DHT11Temperature = 2,\n    //% block=\"DHT11Humidity\"\n    DHT11Humidity = 3,\n    //% block=\"DHT22Temperature\"\n    DHT22Temperature = 4,\n    //% block=\"DHT22Humidity\"\n    DHT22Humidity = 5,\n    //% block=\"DS18B20Temperature\"\n    DS18B20Temperature = 6,\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n    const I2CADDR = 0x33;\n    const MAX_RETRIES = 5;  // 最大重试次数\n    const RETRY_DELAY = 200;  // 重试间隔(ms)\n\n    // 带重试的I2C读取函数\n    function i2cReadWithRetry(address: number, reg: number, length: number): Buffer {\n        // 先尝试获取版本信息，最多重试5次\n        for (let i = 0; i < 5; i++) {\n            if (getVersion() == 0) {\n                // 获取版本成功，执行读取操作\n                pins.i2cWriteNumber(address, reg, NumberFormat.UInt8BE);\n                basic.pause(10);\n                let buf = pins.i2cReadBuffer(address, length);\n                if (buf && buf.length > 0) {\n                    return buf;\n                }\n            }\n            basic.pause(RETRY_DELAY); // 短暂延时后重试\n        }\n        return pins.createBuffer(length); // 所有重试都失败，返回一个与请求长度相同、内容全为0的缓冲区\n    }\n\n    // 带重试的I2C写入函数\n    function i2cWriteWithRetry(address: number, buffer: Buffer): boolean {\n        // 先尝试获取版本信息，最多重试5次\n        for (let i = 0; i < 5; i++) {\n            if (getVersion() == 0) {\n                // 获取版本成功，执行写入操作\n                pins.i2cWriteBuffer(address, buffer);\n                return true;\n            }\n            basic.pause(10); // 短暂延时后重试\n        }\n        return false; // 所有重试都失败\n    }\n\n    // getVersion\n    export function getVersion(): number {\n        pins.i2cWriteNumber(I2CADDR, 0xF0, NumberFormat.UInt8BE);\n        basic.pause(10);\n        let buf = pins.i2cReadBuffer(I2CADDR, 1);\n        if (buf && buf.length > 0 && buf[0] == 0x10) {\n            return 0;  // Communication successful.\n        }\n        return -1;  // Communication faild.\n    }\n    \n    function setMotorPWMPeriod(): void {\n        let buf = pins.createBuffer(5);\n        buf[0] = 0x00;  // I2C_SERVO0_PWM_H\n        buf[1] = 0x00;\n        buf[2] = 0xFF;\n        buf[3] = 0x00;\n        buf[4] = 0xFF;\n        i2cWriteWithRetry(I2CADDR, buf);\n        basic.pause(500);\n    }\n\n    //% block=\"initialize device\"\n    //% weight=100\n    export function initialize(): void {\n        const DATA_ENABLE = 0x01;\n        let buf = pins.createBuffer(2);\n        buf[0] = 0xa0;  // I2C_SERVO0_DUTY_H + number*2\n        buf[1] = DATA_ENABLE;\n        i2cWriteWithRetry(I2CADDR, buf);\n        basic.pause(500);\n        setMotorPWMPeriod();\n    }\n    "],[1,"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n"],[0,"\n}\n"]],"start1":610,"start2":610,"length1":3226,"length2":89}]}]},{"timestamp":1749608850332,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"0\"><"],[-1,"statement name=\"HANDLER\"><block type=\"ExpansionBoard_initialize\"></block></statement><"],[0,"/blo"]],"start1":116,"start2":116,"length1":94,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"    ExpansionBoard.initialize()"],[1,"\t"],[0,"\n})\n"]],"start1":24,"start2":24,"length1":39,"length2":9}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":309,"start2":309,"length1":21,"length2":17}]},{"type":"edited","filename":"ExpansionBoard.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"\n// 360度舵机方向枚举\nenum Servo360Direction {\n    //% block=\"stop\"\n    Stop = 0,\n    //% block=\"forward\"\n    Forward = 1,\n    //% block=\"backward\"\n    Backward = 2\n}\n\n\n"],[0,"/**\n"]],"start1":1517,"start2":1517,"length1":170,"length2":8},{"diffs":[[0,"ace "],[-1,"ExpansionBoard"],[1,"custom"],[0," {\n "]],"start1":1590,"start2":1590,"length1":22,"length2":14},{"diffs":[[0,"  }\n"],[-1,"\n"],[0,"    "],[-1,"//% block=\"read battery level\"\n    //% weight=10\n    export function readBattery(): number {\n        // 先检查版本信息，确认通信正常\n        let buf = i2cReadWithRetry(I2CADDR, 0x87, 1);\n        return buf[0];  // 返回电池电量\n    }\n\n    //% block=\"set pin %pin mode %mode\"\n    //% weight=96\n    export function setPinMode(pin: PinNumber, mode: PinMode): void {\n        let buf = pins.createBuffer(2);\n        buf[0] = 0x2c + pin;  // 设置引脚模式的命令\n        buf[1] = mode;\n        i2cWriteWithRetry(I2CADDR, buf);\n        // 等待引脚初始化\n        basic.pause(10);\n    }\n\n    //% block=\"set pin %pin gpio state %value\"\n    //% weight=95\n    export function setGpioState(pin: PinNumber, value: PinState): void {\n        let buf = pins.createBuffer(2);\n        buf[0] = 0x39 + pin;  // 设置GPIO状态的命令\n        buf[1] = value;\n        i2cWriteWithRetry(I2CADDR, buf);\n    }\n\n    //% weight=90\n    //% blockId=servo_Servo block=\"servo|%index|angle|%angle\"\n    //% angle.min=0 angle.max=180\n    export function servoRun(servo: Servos, angle: number): void {\n        // 限制角度范围在0-180之间\n        angle = Math.max(0, Math.min(180, angle));\n        let period = 500 + angle * 11;\n        let buf = pins.createBuffer(3);\n        buf[0] = 0x1a + servo * 2;  // I2C_SERVO0_ANGLE_H + number*2\n        buf[1] = period >> 8;\n        buf[2] = period & 0xFF;\n        i2cWriteWithRetry(I2CADDR, buf);\n    }\n\n    //% block=\"set 360 servo %servo direction %direction speed %speed\"\n    //% weight=85\n    //% speed.min=0 speed.max=100\n    export function setServo360(servo: Servos, direction: Servo360Direction, speed: number): void {\n        // 限制速度范围在0-100之间\n        speed = Math.max(0, Math.min(100, speed));\n\n        let period = 1500;  // 默认停止值\n\n        if (speed > 0) {\n            switch (direction) {\n                case Servo360Direction.Forward:\n                    // 1450 - (speed * 4.5) 范围：1500 ~ 1000\n                    period = Math.round(1450 - (speed * 4.5));\n                    break;\n                case Servo360Direction.Backward:\n                    // 1550 + (speed * 4.5) 范围：1550 ~ 2000\n                    period = Math.round(1550 + (speed * 4.5));\n                    break;\n                case Servo360Direction.Stop:\n                default:\n                    period = 1500;\n                    break;\n            }\n        }\n        let buf = pins.createBuffer(3);\n        buf[0] = 0x18 + servo * 2;  // I2C_SERVO0_DUTY_H + number*2\n        buf[1] = (period >> 8) & 0xFF;\n        buf[2] = period & 0xFF;\n        i2cWriteWithRetry(I2CADDR, buf);\n    }\n\n    //% block=\"set %emotor direction %edir speed %speed\"\n    //% speed.min=0 speed.max=255\n    //% weight=99\n    export function controlMotor(emotor: MyEnumMotor, edir: MyEnumDir, speed: number): void {\n        // 电机命令地址映射\n        const MOTOR_CMDS = {\n            [MyEnumMotor.M1]: 0x04,\n            [MyEnumMotor.M2]: 0x08,\n            [MyEnumMotor.M3]: 0x0c,\n            [MyEnumMotor.M4]: 0x10\n        };\n\n        // 创建电机控制数据\n        function createMotorData(cmd: number, dir: MyEnumDir, speed: number): Buffer {\n            let buf = pins.createBuffer(5);\n            buf[0] = cmd;\n            if (dir == MyEnumDir.Forward) {\n                buf[1] = 0x00;\n                buf[2] = speed;\n                buf[3] = 0x00;\n                buf[4] = 0x00;\n            } else {\n                buf[1] = 0x00;\n                buf[2] = 0x00;\n                buf[3] = 0x00;\n                buf[4] = speed;\n            }\n            return buf;\n        }\n\n        if (emotor == MyEnumMotor.ALL) {\n            // 控制所有电机\n            let ALLBuf = pins.createBuffer(17);\n            ALLBuf[0] = 0x04;\n\n            // 为每个电机设置控制数据\n            for (let i = 0; i < 4; i++) {\n                const offset = i * 4 + 1;\n                if (edir == MyEnumDir.Forward) {\n                    ALLBuf[offset] = 0x00;\n                    ALLBuf[offset + 1] = speed;\n                    ALLBuf[offset + 2] = 0x00;\n                    ALLBuf[offset + 3] = 0x00;\n                } else {\n                    ALLBuf[offset] = 0x00;\n                    ALLBuf[offset + 1] = 0x00;\n                    ALLBuf[offset + 2] = 0x00;\n                    ALLBuf[offset + 3] = speed;\n                }\n            }\n            i2cWriteWithRetry(I2CADDR, ALLBuf);\n        } else {\n            // 控制单个电机\n            const cmd = MOTOR_CMDS[emotor];\n            const buf = createMotorData(cmd, edir, speed);\n            i2cWriteWithRetry(I2CADDR, buf);\n        }\n    }\n\n    //% block=\"set %emotor stop\"\n    //% weight=98\n    export function controlMotorStop(emotor: MyEnumMotor): void {\n        // 停止电机就是设置速度为0\n        controlMotor(emotor, MyEnumDir.Forward, 0);\n    }\n\n    //% block=\"read %type from pin %pin\"\n    //% weight=87\n    export function readSensor(pin: PinNumber, type: SensorType): number {\n        const DATA_ENABLE = 0x01;\n        const MODE_ERROR = 0x02;\n        const RETRY_COUNT = 3;\n\n        switch (type) {\n            case SensorType.Analog:\n                // ADC读取\n                let adcBuf = i2cReadWithRetry(I2CADDR, 0x45 + pin * 3, 3);\n                if (adcBuf && adcBuf[0] == DATA_ENABLE) {\n                    let adcValue = (adcBuf[1] << 8) | adcBuf[2];\n                    if (adcValue > 3900) {\n                        adcValue = 4095;\n                    } else if (adcValue < 40) {\n                        adcValue = 0;\n                    }\n                    return adcValue;\n                }\n                return 0xFFFF;\n\n            case SensorType.Digital:\n                // GPIO读取\n                let gpioBuf = i2cReadWithRetry(I2CADDR, 0x3f + pin, 1);\n                return gpioBuf ? gpioBuf[0] : 0xFF;\n\n            case SensorType.DHT11Temperature:\n                // DHT11温度读取\n                let enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht11TempBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 3);\n                if (dht11TempBuf && dht11TempBuf[0] == DATA_ENABLE) {\n                    let sign = 1.0;\n                    if (dht11TempBuf[1] & 0x80) {\n                        dht11TempBuf[1] &= 0x7f;\n                        sign = -1.0;\n                    }\n                    return (dht11TempBuf[1] + dht11TempBuf[2] * 0.01) * sign;\n                }\n                return 0;\n\n            case SensorType.DHT11Humidity:\n                // DHT11湿度读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht11HumBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 5);\n                if (dht11HumBuf && dht11HumBuf[0] == DATA_ENABLE) {\n                    return dht11HumBuf[3] + dht11HumBuf[4] * 0.01;\n                }\n                return 0;\n\n            case SensorType.DHT22Temperature:\n                // DHT22温度读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht22TempBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 3);\n                if (dht22TempBuf && dht22TempBuf[0] == DATA_ENABLE) {\n                    let sign = 1.0;\n                    if (dht22TempBuf[1] & 0x80) {\n                        dht22TempBuf[1] &= 0x7f;\n                        sign = -1.0;\n                    }\n                    return (dht22TempBuf[1] + dht22TempBuf[2] * 0.01) * sign;\n                }\n                return 0;\n\n            case SensorType.DHT22Humidity:\n                // DHT22湿度读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht22HumBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 5);\n                if (dht22HumBuf && dht22HumBuf[0] == DATA_ENABLE) {\n                    return dht22HumBuf[3] + dht22HumBuf[4] * 0.01;\n                }\n                return 0;\n\n            case SensorType.DS18B20Temperature:\n                // DS18B20读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x75 + pin * 3;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(100);\n                let ds18b20Buf = i2cReadWithRetry(I2CADDR, 0x75 + pin * 3, 3);\n                if (ds18b20Buf && ds18b20Buf[0] == DATA_ENABLE) {\n                    if (ds18b20Buf[1] == 0xff && ds18b20Buf[2] == 0xff) {\n                        return 0.0;\n                    }\n                    let sign = 1.0;\n                    if (ds18b20Buf[1] & 0x80) {\n                        ds18b20Buf[1] &= 0x7f;\n                        sign = -1.0;\n                    }\n                    return ((ds18b20Buf[1] * 256 + ds18b20Buf[2]) / 16.0) * sign;\n                }\n                return 0.0;\n            default:\n                return 0;\n        }\n    }"],[0,"\n}\n"]],"start1":3804,"start2":3804,"length1":9285,"length2":11}]}]},{"timestamp":1749609143979,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":309,"start2":309,"length1":17,"length2":21}]},{"type":"edited","filename":"ExpansionBoard.ts","patch":[{"diffs":[[1,"\n"],[0,"/**\n"],[-1," "],[0,"* "],[-1,"Use this file to define custom functions and graphical blocks.\n * For more details, please visit"],[1,"使用此文件来定义自定义函数和图形块。\n* 想了解更详细的信息，请前往"],[0," htt"]],"start1":0,"start2":0,"length1":107,"length2":45},{"diffs":[[0,"tom\n"],[-1," "],[0,"*/\n\n//"],[-1," "],[0,"Moto"]],"start1":82,"start2":82,"length1":16,"length2":14},{"diffs":[[0,"  ALL,\n}"],[1,";"],[0,"\n\n//"],[-1," "],[0,"Motor di"]],"start1":269,"start2":269,"length1":21,"length2":21},{"diffs":[[0,"tion enumeration"],[1," selection"],[0,"\nenum MyEnumDir "]],"start1":293,"start2":293,"length1":32,"length2":42},{"diffs":[[0,"d,\n}"],[1,";"],[0,"\n"],[-1,"\n// Servo ports enumeration"],[0,"\nenu"]],"start1":410,"start2":410,"length1":36,"length2":10},{"diffs":[[0,"\n}\n\n"],[-1,"// Example general-purpose enumeration\n"],[0,"enum"]],"start1":589,"start2":589,"length1":47,"length2":8},{"diffs":[[0,"\n}\n\n"],[-1,"// Pin number enumeration\n"],[0,"enum"]],"start1":663,"start2":663,"length1":34,"length2":8},{"diffs":[[0,"\n}\n\n"],[-1,"// Pin mode enumeration\n"],[0,"enum"]],"start1":775,"start2":775,"length1":32,"length2":8},{"diffs":[[0,"\n}\n\n"],[-1,"// Pin state enumeration\n"],[0,"enum"]],"start1":1032,"start2":1032,"length1":33,"length2":8},{"diffs":[[0,"\n// "],[-1,"Sensor type enumeration"],[1,"传感器类型枚举"],[0,"\nenu"]],"start1":1121,"start2":1121,"length1":31,"length2":15},{"diffs":[[0,"\n}\n\n"],[1,"\n"],[0,"// 360"],[-1,"-degree servo direction enumeration"],[1,"度舵机方向枚举"],[0,"\nenu"]],"start1":1517,"start2":1517,"length1":49,"length2":22},{"diffs":[[0," = 2\n}\n\n"],[1,"\n"],[0,"/**\n * C"]],"start1":1674,"start2":1674,"length1":16,"length2":17},{"diffs":[[0,"ocks"],[-1," namespace for expansion board"],[0,"\n */"]],"start1":1699,"start2":1699,"length1":38,"length2":8},{"diffs":[[0,"x33;"],[-1,"        // I2C device address\n    const MAX_RETRIES = 5;       // Maximum retry attempts\n    const RETRY_DELAY = 200;     // Retry delay in milliseconds\n\n    // I2C read function with retry mechanism"],[1,"\n    const MAX_RETRIES = 5;  // 最大重试次数\n    const RETRY_DELAY = 200;  // 重试间隔(ms)\n\n    // 带重试的I2C读取函数"],[0,"\n   "]],"start1":1794,"start2":1794,"length1":207,"length2":108},{"diffs":[[0,"mber): Buffer {\n"],[1,"        // 先尝试获取版本信息，最多重试5次\n"],[0,"        for (let"]],"start1":1969,"start2":1969,"length1":32,"length2":60},{"diffs":[[0," i = 0; i < "],[-1,"MAX_RETRIES"],[1,"5"],[0,"; i++) {\n   "]],"start1":2029,"start2":2029,"length1":35,"length2":25},{"diffs":[[0,"rsion() == 0) {\n"],[1,"                // 获取版本成功，执行读取操作\n"],[0,"                "]],"start1":2072,"start2":2072,"length1":32,"length2":65},{"diffs":[[0,"_DELAY);"],[1," // 短暂延时后重试"],[0,"\n       "]],"start1":2428,"start2":2428,"length1":16,"length2":27},{"diffs":[[0," // "],[-1,"Return zero-filled buffer on failure\n    }\n\n    // I2C write function with retry mechanism"],[1,"所有重试都失败，返回一个与请求长度相同、内容全为0的缓冲区\n    }\n\n    // 带重试的I2C写入函数"],[0,"\n   "]],"start1":2499,"start2":2499,"length1":98,"length2":63},{"diffs":[[0,": boolean {\n"],[1,"        // 先尝试获取版本信息，最多重试5次\n"],[0,"        for "]],"start1":2622,"start2":2622,"length1":24,"length2":52},{"diffs":[[0," 0; i < "],[-1,"MAX_RETRIES"],[1,"5"],[0,"; i++) {"]],"start1":2682,"start2":2682,"length1":27,"length2":17},{"diffs":[[0,"rsion() == 0) {\n"],[1,"                // 获取版本成功，执行写入操作\n"],[0,"                "]],"start1":2721,"start2":2721,"length1":32,"length2":65},{"diffs":[[0,"basic.pause(10);"],[1," // 短暂延时后重试"],[0,"\n        }\n     "]],"start1":2879,"start2":2879,"length1":32,"length2":43},{"diffs":[[0,"n false;"],[1," // 所有重试都失败"],[0,"\n    }\n\n"]],"start1":2930,"start2":2930,"length1":16,"length2":27},{"diffs":[[0," // "],[-1,"Get firmware version (used for checking communication status)"],[1,"getVersion"],[0,"\n   "]],"start1":2960,"start2":2960,"length1":69,"length2":18},{"diffs":[[0,"eturn 0;"],[1," "],[0," // Comm"]],"start1":3227,"start2":3227,"length1":16,"length2":17},{"diffs":[[0,"ccessful"],[1,"."],[0,"\n       "]],"start1":3256,"start2":3256,"length1":16,"length2":17},{"diffs":[[0,"turn -1;"],[1," "],[0," // Comm"]],"start1":3286,"start2":3286,"length1":16,"length2":17},{"diffs":[[0,"fail"],[-1,"e"],[0,"d"],[1,"."],[0,"\n    }\n"],[-1,"\n"],[0,"    "],[-1,"// Set motor PWM period (used for initialization)"],[0,"\n   "]],"start1":3313,"start2":3313,"length1":71,"length2":21},{"diffs":[[0,"  buf[0] = 0x00;"],[1,"  // I2C_SERVO0_PWM_H"],[0,"\n        buf[1] "]],"start1":3418,"start2":3418,"length1":32,"length2":53},{"diffs":[[0," // "],[-1,"Command to enable device"],[1,"I2C_SERVO0_DUTY_H + number*2"],[0,"\n   "]],"start1":3813,"start2":3813,"length1":32,"length2":36},{"diffs":[[0,"d();"],[-1," // Set initial PWM"],[0,"\n   "]],"start1":3967,"start2":3967,"length1":27,"length2":8},{"diffs":[[0,"ery "],[-1,"percentage"],[1,"level"],[0,"\"\n  "]],"start1":4003,"start2":4003,"length1":18,"length2":13},{"diffs":[[0,"ery(): number {\n"],[1,"        // 先检查版本信息，确认通信正常\n"],[0,"        let buf "]],"start1":4060,"start2":4060,"length1":32,"length2":58},{"diffs":[[0," // "],[-1,"Return battery level (0–255)"],[1,"返回电池电量"],[0,"\n   "]],"start1":4179,"start2":4179,"length1":36,"length2":14},{"diffs":[[0," 0x2c + pin;"],[1,"  // 设置引脚模式的命令"],[0,"\n        buf"]],"start1":4381,"start2":4381,"length1":24,"length2":38},{"diffs":[[0,"    "],[-1,"basic.pause(10); // Delay for initialization"],[1,"// 等待引脚初始化\n        basic.pause(10);"],[0,"\n   "]],"start1":4476,"start2":4476,"length1":52,"length2":43},{"diffs":[[0,"9 + pin;"],[1,"  // 设置GPIO状态的命令"],[0,"\n       "]],"start1":4722,"start2":4722,"length1":16,"length2":32},{"diffs":[[0,"number): void {\n"],[1,"        // 限制角度范围在0-180之间\n"],[0,"        angle = "]],"start1":4984,"start2":4984,"length1":32,"length2":58},{"diffs":[[0,"e));"],[-1," // Clamp angle"],[0,"\n   "]],"start1":5072,"start2":5072,"length1":23,"length2":8},{"diffs":[[0,"x1a + servo * 2;"],[1,"  // I2C_SERVO0_ANGLE_H + number*2"],[0,"\n        buf[1] "]],"start1":5174,"start2":5174,"length1":32,"length2":66},{"diffs":[[0,"number): void {\n"],[1,"        // 限制速度范围在0-100之间\n"],[0,"        speed = "]],"start1":5542,"start2":5542,"length1":32,"length2":58},{"diffs":[[0,"d));"],[-1," // Clamp speed"],[1,"\n"],[0,"\n   "]],"start1":5630,"start2":5630,"length1":23,"length2":9},{"diffs":[[0,"500;"],[1," "],[0," // "],[-1,"Default stop value"],[1,"默认停止值"],[0,"\n\n  "]],"start1":5658,"start2":5658,"length1":30,"length2":18},{"diffs":[[0,"on.Forward:\n"],[1,"                    // 1450 - (speed * 4.5) 范围：1500 ~ 1000\n"],[0,"            "]],"start1":5768,"start2":5768,"length1":24,"length2":83},{"diffs":[[0,"5));"],[-1," // Forward pulse width"],[0,"\n   "]],"start1":5897,"start2":5897,"length1":31,"length2":8},{"diffs":[[0,"n.Backward:\n"],[1,"                    // 1550 + (speed * 4.5) 范围：1550 ~ 2000\n"],[0,"            "]],"start1":5966,"start2":5966,"length1":24,"length2":83},{"diffs":[[0,"5));"],[-1," // Backward pulse width"],[0,"\n   "]],"start1":6095,"start2":6095,"length1":32,"length2":8},{"diffs":[[0,"         break;\n"],[1,"                case Servo360Direction.Stop:\n"],[0,"                "]],"start1":6111,"start2":6111,"length1":32,"length2":77},{"diffs":[[0,"500;"],[-1," // Stop"],[0,"\n   "]],"start1":6227,"start2":6227,"length1":16,"length2":8},{"diffs":[[0,"    }\n        }\n"],[-1,"\n"],[0,"        let buf "]],"start1":6267,"start2":6267,"length1":33,"length2":32},{"diffs":[[0,"rvo * 2;"],[1,"  // I2C_SERVO0_DUTY_H + number*2"],[0,"\n       "]],"start1":6349,"start2":6349,"length1":16,"length2":49},{"diffs":[[0,"number): void {\n"],[1,"        // 电机命令地址映射\n"],[0,"        const MO"]],"start1":6697,"start2":6697,"length1":32,"length2":52},{"diffs":[[0," // "],[-1,"Helper function to create motor data buffer"],[1,"创建电机控制数据"],[0,"\n   "]],"start1":6924,"start2":6924,"length1":51,"length2":16},{"diffs":[[0," // "],[-1,"Send a full 4-motor command"],[1,"控制所有电机"],[0,"\n   "]],"start1":7510,"start2":7510,"length1":35,"length2":14},{"diffs":[[0," = 0x04;"],[1,"\n\n            // 为每个电机设置控制数据"],[0,"\n       "]],"start1":7590,"start2":7590,"length1":16,"length2":44},{"diffs":[[0,"        "],[-1,"le"],[1,"// 控制单个电机\n            cons"],[0,"t cmd = "]],"start1":8256,"start2":8256,"length1":18,"length2":42},{"diffs":[[0,"    "],[-1,"let buf = createMotorData(cmd, edir, speed);\n            i2cWriteWithRetry(I2CADDR, buf)"],[1,"const buf = createMotorData(cmd, edir, speed);\n            i2cWriteWithRetry(I2CADDR, buf);\n        }\n    }\n\n    //% block=\"set %emotor stop\"\n    //% weight=98\n    export function controlMotorStop(emotor: MyEnumMotor): void {\n        // 停止电机就是设置速度为0\n        controlMotor(emotor, MyEnumDir.Forward, 0);\n    }\n\n    //% block=\"read %type from pin %pin\"\n    //% weight=87\n    export function readSensor(pin: PinNumber, type: SensorType): number {\n        const DATA_ENABLE = 0x01;\n        const MODE_ERROR = 0x02;\n        const RETRY_COUNT = 3;\n\n        switch (type) {\n            case SensorType.Analog:\n                // ADC读取\n                let adcBuf = i2cReadWithRetry(I2CADDR, 0x45 + pin * 3, 3);\n                if (adcBuf && adcBuf[0] == DATA_ENABLE) {\n                    let adcValue = (adcBuf[1] << 8) | adcBuf[2];\n                    if (adcValue > 3900) {\n                        adcValue = 4095;\n                    } else if (adcValue < 40) {\n                        adcValue = 0;\n                    }\n                    return adcValue;\n                }\n                return 0xFFFF;\n\n            case SensorType.Digital:\n                // GPIO读取\n                let gpioBuf = i2cReadWithRetry(I2CADDR, 0x3f + pin, 1);\n                return gpioBuf ? gpioBuf[0] : 0xFF;\n\n            case SensorType.DHT11Temperature:\n                // DHT11温度读取\n                let enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht11TempBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 3);\n                if (dht11TempBuf && dht11TempBuf[0] == DATA_ENABLE) {\n                    let sign = 1.0;\n                    if (dht11TempBuf[1] & 0x80) {\n                        dht11TempBuf[1] &= 0x7f;\n                        sign = -1.0;\n                    }\n                    return (dht11TempBuf[1] + dht11TempBuf[2] * 0.01) * sign;\n                }\n                return 0;\n\n            case SensorType.DHT11Humidity:\n                // DHT11湿度读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht11HumBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 5);\n                if (dht11HumBuf && dht11HumBuf[0] == DATA_ENABLE) {\n                    return dht11HumBuf[3] + dht11HumBuf[4] * 0.01;\n                }\n                return 0;\n\n            case SensorType.DHT22Temperature:\n                // DHT22温度读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht22TempBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 3);\n                if (dht22TempBuf && dht22TempBuf[0] == DATA_ENABLE) {\n                    let sign = 1.0;\n                    if (dht22TempBuf[1] & 0x80) {\n                        dht22TempBuf[1] &= 0x7f;\n                        sign = -1.0;\n                    }\n                    return (dht22TempBuf[1] + dht22TempBuf[2] * 0.01) * sign;\n                }\n                return 0;\n\n            case SensorType.DHT22Humidity:\n                // DHT22湿度读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht22HumBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 5);\n                if (dht22HumBuf && dht22HumBuf[0] == DATA_ENABLE) {\n                    return dht22HumBuf[3] + dht22HumBuf[4] * 0.01;\n                }\n                return 0;\n\n            case SensorType.DS18B20Temperature:\n                // DS18B20读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x75 + pin * 3;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(100);\n                let ds18b20Buf = i2cReadWithRetry(I2CADDR, 0x75 + pin * 3, 3);\n                if (ds18b20Buf && ds18b20Buf[0] == DATA_ENABLE) {\n                    if (ds18b20Buf[1] == 0xff && ds18b20Buf[2] == 0xff) {\n                        return 0.0;\n                    }\n                    let sign = 1.0;\n                    if (ds18b20Buf[1] & 0x80) {\n                        ds18b20Buf[1] &= 0x7f;\n                        sign = -1.0;\n                    }\n                    return ((ds18b20Buf[1] * 256 + ds18b20Buf[2]) / 16.0) * sign;\n                }\n                return 0.0;\n            default:\n                return 0"],[0,";\n  "]],"start1":8326,"start2":8326,"length1":96,"length2":4917}]}]},{"timestamp":1749610133142,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"device_forever\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"ExpansionBoard_initialize\"></block></statement></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":148}]}]},{"timestamp":1749610183520,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":289,"start2":289,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// 在此处测试；当此软件包作为插件使用时，将不会编译此软件包。\n"}]}],"snapshots":[{"timestamp":1749607676159,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt - Expansion Board for micro:bit & K10\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1749609483270,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"ExpansionBoard_initialize\"></block></statement></block></xml>","main.ts":"","README.md":"","ExpansionBoard.ts":"\n/**\n* 使用此文件来定义自定义函数和图形块。\n* 想了解更详细的信息，请前往 https://makecode.microbit.org/blocks/custom\n*/\n\n//Motor selection enumeration\nenum MyEnumMotor {\n    //% block=\"M1\"\n    M1,\n    //% block=\"M2\"\n    M2,\n    //% block=\"M3\"\n    M3,\n    //% block=\"M4\"\n    M4,\n    //% block=\"ALL\"\n    ALL,\n};\n\n//Motor direction enumeration selection\nenum MyEnumDir {\n    //% block=\"forward\"\n    Forward,\n    //% block=\"backward\"\n    Backward,\n};\n\nenum Servos {\n    //% blockId=\"S1\" block=\"S1\"\n    S1,\n    //% blockId=\"S2\" block=\"S2\"\n    S2,\n    //% blockId=\"S3\" block=\"S3\"\n    S3,\n    //% blockId=\"S4\" block=\"S4\"\n    S4\n}\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\nenum PinNumber {\n    //% block=\"C0\"\n    C0 = 0,\n    //% block=\"C1\"\n    C1 = 1,\n    //% block=\"C2\"\n    C2 = 2\n}\n\nenum PinMode {\n    //% block=\"ADC\"\n    ADC = 0,\n    //% block=\"DHT11\"\n    DHT11 = 1,\n    //% block=\"DHT22\"\n    DHT22 = 2,\n    //% block=\"DS18B20\"\n    DS18B20 = 3,\n    //% block=\"Digital OUT\"\n    WriteGpio = 4,\n    //% block=\"Digital IN\"\n    ReadGpio = 5\n}\n\nenum PinState {\n    //% block=\"low\"\n    Low = 0,\n    //% block=\"high\"\n    High = 1\n}\n\n// 传感器类型枚举\nenum SensorType {\n    //% block=\"ADC\"\n    Analog = 0,\n    //% block=\"digital in\"\n    Digital = 1,\n    //% block=\"DHT11Temperature\"\n    DHT11Temperature = 2,\n    //% block=\"DHT11Humidity\"\n    DHT11Humidity = 3,\n    //% block=\"DHT22Temperature\"\n    DHT22Temperature = 4,\n    //% block=\"DHT22Humidity\"\n    DHT22Humidity = 5,\n    //% block=\"DS18B20Temperature\"\n    DS18B20Temperature = 6,\n}\n\n\n// 360度舵机方向枚举\nenum Servo360Direction {\n    //% block=\"stop\"\n    Stop = 0,\n    //% block=\"forward\"\n    Forward = 1,\n    //% block=\"backward\"\n    Backward = 2\n}\n\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace ExpansionBoard {\n    const I2CADDR = 0x33;\n    const MAX_RETRIES = 5;  // 最大重试次数\n    const RETRY_DELAY = 200;  // 重试间隔(ms)\n\n    // 带重试的I2C读取函数\n    function i2cReadWithRetry(address: number, reg: number, length: number): Buffer {\n        // 先尝试获取版本信息，最多重试5次\n        for (let i = 0; i < 5; i++) {\n            if (getVersion() == 0) {\n                // 获取版本成功，执行读取操作\n                pins.i2cWriteNumber(address, reg, NumberFormat.UInt8BE);\n                basic.pause(10);\n                let buf = pins.i2cReadBuffer(address, length);\n                if (buf && buf.length > 0) {\n                    return buf;\n                }\n            }\n            basic.pause(RETRY_DELAY); // 短暂延时后重试\n        }\n        return pins.createBuffer(length); // 所有重试都失败，返回一个与请求长度相同、内容全为0的缓冲区\n    }\n\n    // 带重试的I2C写入函数\n    function i2cWriteWithRetry(address: number, buffer: Buffer): boolean {\n        // 先尝试获取版本信息，最多重试5次\n        for (let i = 0; i < 5; i++) {\n            if (getVersion() == 0) {\n                // 获取版本成功，执行写入操作\n                pins.i2cWriteBuffer(address, buffer);\n                return true;\n            }\n            basic.pause(10); // 短暂延时后重试\n        }\n        return false; // 所有重试都失败\n    }\n\n    // getVersion\n    export function getVersion(): number {\n        pins.i2cWriteNumber(I2CADDR, 0xF0, NumberFormat.UInt8BE);\n        basic.pause(10);\n        let buf = pins.i2cReadBuffer(I2CADDR, 1);\n        if (buf && buf.length > 0 && buf[0] == 0x10) {\n            return 0;  // Communication successful.\n        }\n        return -1;  // Communication faild.\n    }\n    \n    function setMotorPWMPeriod(): void {\n        let buf = pins.createBuffer(5);\n        buf[0] = 0x00;  // I2C_SERVO0_PWM_H\n        buf[1] = 0x00;\n        buf[2] = 0xFF;\n        buf[3] = 0x00;\n        buf[4] = 0xFF;\n        i2cWriteWithRetry(I2CADDR, buf);\n        basic.pause(500);\n    }\n\n    //% block=\"initialize device\"\n    //% weight=100\n    export function initialize(): void {\n        const DATA_ENABLE = 0x01;\n        let buf = pins.createBuffer(2);\n        buf[0] = 0xa0;  // I2C_SERVO0_DUTY_H + number*2\n        buf[1] = DATA_ENABLE;\n        i2cWriteWithRetry(I2CADDR, buf);\n        basic.pause(500);\n        setMotorPWMPeriod();\n    }\n\n    //% block=\"read battery level\"\n    //% weight=10\n    export function readBattery(): number {\n        // 先检查版本信息，确认通信正常\n        let buf = i2cReadWithRetry(I2CADDR, 0x87, 1);\n        return buf[0];  // 返回电池电量\n    }\n\n    //% block=\"set pin %pin mode %mode\"\n    //% weight=96\n    export function setPinMode(pin: PinNumber, mode: PinMode): void {\n        let buf = pins.createBuffer(2);\n        buf[0] = 0x2c + pin;  // 设置引脚模式的命令\n        buf[1] = mode;\n        i2cWriteWithRetry(I2CADDR, buf);\n        // 等待引脚初始化\n        basic.pause(10);\n    }\n\n    //% block=\"set pin %pin gpio state %value\"\n    //% weight=95\n    export function setGpioState(pin: PinNumber, value: PinState): void {\n        let buf = pins.createBuffer(2);\n        buf[0] = 0x39 + pin;  // 设置GPIO状态的命令\n        buf[1] = value;\n        i2cWriteWithRetry(I2CADDR, buf);\n    }\n\n    //% weight=90\n    //% blockId=servo_Servo block=\"servo|%index|angle|%angle\"\n    //% angle.min=0 angle.max=180\n    export function servoRun(servo: Servos, angle: number): void {\n        // 限制角度范围在0-180之间\n        angle = Math.max(0, Math.min(180, angle));\n        let period = 500 + angle * 11;\n        let buf = pins.createBuffer(3);\n        buf[0] = 0x1a + servo * 2;  // I2C_SERVO0_ANGLE_H + number*2\n        buf[1] = period >> 8;\n        buf[2] = period & 0xFF;\n        i2cWriteWithRetry(I2CADDR, buf);\n    }\n\n    //% block=\"set 360 servo %servo direction %direction speed %speed\"\n    //% weight=85\n    //% speed.min=0 speed.max=100\n    export function setServo360(servo: Servos, direction: Servo360Direction, speed: number): void {\n        // 限制速度范围在0-100之间\n        speed = Math.max(0, Math.min(100, speed));\n\n        let period = 1500;  // 默认停止值\n\n        if (speed > 0) {\n            switch (direction) {\n                case Servo360Direction.Forward:\n                    // 1450 - (speed * 4.5) 范围：1500 ~ 1000\n                    period = Math.round(1450 - (speed * 4.5));\n                    break;\n                case Servo360Direction.Backward:\n                    // 1550 + (speed * 4.5) 范围：1550 ~ 2000\n                    period = Math.round(1550 + (speed * 4.5));\n                    break;\n                case Servo360Direction.Stop:\n                default:\n                    period = 1500;\n                    break;\n            }\n        }\n        let buf = pins.createBuffer(3);\n        buf[0] = 0x18 + servo * 2;  // I2C_SERVO0_DUTY_H + number*2\n        buf[1] = (period >> 8) & 0xFF;\n        buf[2] = period & 0xFF;\n        i2cWriteWithRetry(I2CADDR, buf);\n    }\n\n    //% block=\"set %emotor direction %edir speed %speed\"\n    //% speed.min=0 speed.max=255\n    //% weight=99\n    export function controlMotor(emotor: MyEnumMotor, edir: MyEnumDir, speed: number): void {\n        // 电机命令地址映射\n        const MOTOR_CMDS = {\n            [MyEnumMotor.M1]: 0x04,\n            [MyEnumMotor.M2]: 0x08,\n            [MyEnumMotor.M3]: 0x0c,\n            [MyEnumMotor.M4]: 0x10\n        };\n\n        // 创建电机控制数据\n        function createMotorData(cmd: number, dir: MyEnumDir, speed: number): Buffer {\n            let buf = pins.createBuffer(5);\n            buf[0] = cmd;\n            if (dir == MyEnumDir.Forward) {\n                buf[1] = 0x00;\n                buf[2] = speed;\n                buf[3] = 0x00;\n                buf[4] = 0x00;\n            } else {\n                buf[1] = 0x00;\n                buf[2] = 0x00;\n                buf[3] = 0x00;\n                buf[4] = speed;\n            }\n            return buf;\n        }\n\n        if (emotor == MyEnumMotor.ALL) {\n            // 控制所有电机\n            let ALLBuf = pins.createBuffer(17);\n            ALLBuf[0] = 0x04;\n\n            // 为每个电机设置控制数据\n            for (let i = 0; i < 4; i++) {\n                const offset = i * 4 + 1;\n                if (edir == MyEnumDir.Forward) {\n                    ALLBuf[offset] = 0x00;\n                    ALLBuf[offset + 1] = speed;\n                    ALLBuf[offset + 2] = 0x00;\n                    ALLBuf[offset + 3] = 0x00;\n                } else {\n                    ALLBuf[offset] = 0x00;\n                    ALLBuf[offset + 1] = 0x00;\n                    ALLBuf[offset + 2] = 0x00;\n                    ALLBuf[offset + 3] = speed;\n                }\n            }\n            i2cWriteWithRetry(I2CADDR, ALLBuf);\n        } else {\n            // 控制单个电机\n            const cmd = MOTOR_CMDS[emotor];\n            const buf = createMotorData(cmd, edir, speed);\n            i2cWriteWithRetry(I2CADDR, buf);\n        }\n    }\n\n    //% block=\"set %emotor stop\"\n    //% weight=98\n    export function controlMotorStop(emotor: MyEnumMotor): void {\n        // 停止电机就是设置速度为0\n        controlMotor(emotor, MyEnumDir.Forward, 0);\n    }\n\n    //% block=\"read %type from pin %pin\"\n    //% weight=87\n    export function readSensor(pin: PinNumber, type: SensorType): number {\n        const DATA_ENABLE = 0x01;\n        const MODE_ERROR = 0x02;\n        const RETRY_COUNT = 3;\n\n        switch (type) {\n            case SensorType.Analog:\n                // ADC读取\n                let adcBuf = i2cReadWithRetry(I2CADDR, 0x45 + pin * 3, 3);\n                if (adcBuf && adcBuf[0] == DATA_ENABLE) {\n                    let adcValue = (adcBuf[1] << 8) | adcBuf[2];\n                    if (adcValue > 3900) {\n                        adcValue = 4095;\n                    } else if (adcValue < 40) {\n                        adcValue = 0;\n                    }\n                    return adcValue;\n                }\n                return 0xFFFF;\n\n            case SensorType.Digital:\n                // GPIO读取\n                let gpioBuf = i2cReadWithRetry(I2CADDR, 0x3f + pin, 1);\n                return gpioBuf ? gpioBuf[0] : 0xFF;\n\n            case SensorType.DHT11Temperature:\n                // DHT11温度读取\n                let enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht11TempBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 3);\n                if (dht11TempBuf && dht11TempBuf[0] == DATA_ENABLE) {\n                    let sign = 1.0;\n                    if (dht11TempBuf[1] & 0x80) {\n                        dht11TempBuf[1] &= 0x7f;\n                        sign = -1.0;\n                    }\n                    return (dht11TempBuf[1] + dht11TempBuf[2] * 0.01) * sign;\n                }\n                return 0;\n\n            case SensorType.DHT11Humidity:\n                // DHT11湿度读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht11HumBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 5);\n                if (dht11HumBuf && dht11HumBuf[0] == DATA_ENABLE) {\n                    return dht11HumBuf[3] + dht11HumBuf[4] * 0.01;\n                }\n                return 0;\n\n            case SensorType.DHT22Temperature:\n                // DHT22温度读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht22TempBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 3);\n                if (dht22TempBuf && dht22TempBuf[0] == DATA_ENABLE) {\n                    let sign = 1.0;\n                    if (dht22TempBuf[1] & 0x80) {\n                        dht22TempBuf[1] &= 0x7f;\n                        sign = -1.0;\n                    }\n                    return (dht22TempBuf[1] + dht22TempBuf[2] * 0.01) * sign;\n                }\n                return 0;\n\n            case SensorType.DHT22Humidity:\n                // DHT22湿度读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x57 + pin * 5;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(30);\n                let dht22HumBuf = i2cReadWithRetry(I2CADDR, 0x57 + pin * 5, 5);\n                if (dht22HumBuf && dht22HumBuf[0] == DATA_ENABLE) {\n                    return dht22HumBuf[3] + dht22HumBuf[4] * 0.01;\n                }\n                return 0;\n\n            case SensorType.DS18B20Temperature:\n                // DS18B20读取\n                enableBuf = pins.createBuffer(2);\n                enableBuf[0] = 0x75 + pin * 3;\n                enableBuf[1] = DATA_ENABLE;\n                i2cWriteWithRetry(I2CADDR, enableBuf);\n                basic.pause(100);\n                let ds18b20Buf = i2cReadWithRetry(I2CADDR, 0x75 + pin * 3, 3);\n                if (ds18b20Buf && ds18b20Buf[0] == DATA_ENABLE) {\n                    if (ds18b20Buf[1] == 0xff && ds18b20Buf[2] == 0xff) {\n                        return 0.0;\n                    }\n                    let sign = 1.0;\n                    if (ds18b20Buf[1] & 0x80) {\n                        ds18b20Buf[1] &= 0x7f;\n                        sign = -1.0;\n                    }\n                    return ((ds18b20Buf[1] * 256 + ds18b20Buf[2]) / 16.0) * sign;\n                }\n                return 0.0;\n            default:\n                return 0;\n        }\n    }\n}\n","pxt.json":"{\n    \"name\": \"pxt - Expansion Board for micro:bit & K10\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"ExpansionBoard.ts\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}}],"shares":[],"lastSaveTime":1749610183525}